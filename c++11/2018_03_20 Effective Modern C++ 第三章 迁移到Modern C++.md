# 迁移到Modern C++

## 一、区别圆括号和花括号在创建对象的时候

### 1.对象初始化的时候不使用 “=” 赋值操作符

```cpp
int x = { 0 };

int y{ 0 };

Widget w1;       // call default constructor

Widget w2 = w1;  // not an assignment; calls copy ctor

w1 = w2;         // an assignment; calls copy operator=
``` 
- 这里经常造成初学者的困扰，对于语言内置的类型没有任何的区别，对于自定义的类型，这里有赋值操作符，但是并没有调用拷贝构造函数，而是调用了默认的构造函数。

- 花括号可以用来初始化非静态数据成员，可以用来初始化不可拷贝的对象（不可以使用赋值操作符）。

- 花括号初始化禁止内置类型的“狭隘的隐式转换”（无法完全保留转换之前的数据的转换）

- 初始化一个无参数的对象，要使用花括号，而不能使用圆括号，圆括号的方式会和定义一个成员函数的形式冲突，只能使用花括号的形式。

- 花括号的初始化会导致一下令人困惑的行为：因为新的c++标准中添加了std::initializer, 当初始化的时候新的标准里会优先解析成初始化列表，而不是对应的参数，当一个类的构造函数中包含初始化列表，你使用花括号的初始化时，会优先使用初始化列表的构造函数，即使构造参数中有类型完全符合的构造函数，初始化列表页会根据参数的类型先进行隐式转换，转换成初始化列表中的类型（即使初始化列表中的类型并不是一致的），如果构造的花括号中的类型完全没有办法和初始化列表中的类型进行转换时，函数的构造会回退到构造函数的重载。编译器选择会优先选择初始化列表初始化，即使需要进行隐式转换。

- 调用空的初始化列表的构造函数需要这样调用，否则会认为是空参数的构造函数

```cpp
Widget w4({}); 
Widget w5{{}};
```

- 在有些时候，对象的初始化时使用圆括号和花括号表示的行为是完全不一样的。文章推荐当你在实现自己的构造函数时尽量避免花括号和圆括号的初始化会有不同语义的实现。

```cpp
std::vector<int> v1(10, 20); // use non-std::initializer_list // ctor: create 10-element
                                 // std::vector, all elements have
                                 // value of 20
std::vector<int> v2{10, 20}; // use std::initializer_list ctor: // create 2-element std::vector,
                                 // element values are 10 and 20
```
